// Generated by CoffeeScript 1.10.0
(function() {
  var EventEmitter, Nano, Queue,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Nano = require('nano');

  EventEmitter = require('events');

  Queue = (function(superClass) {
    extend(Queue, superClass);

    function Queue(db, url, auth) {
      var nano;
      this.db = db != null ? db : 'couch-queue';
      if (url == null) {
        url = 'http://127.0.0.1:5984';
      }
      nano = new Nano(url);
      if (auth != null) {
        if (!(auth.username && auth.password)) {
          return process.nextTick((function(_this) {
            return function() {
              return _this.emit('error', "Both username and password needed to authenticate");
            };
          })(this));
        }
        this.username = auth.username;
        nano.auth(auth.username, auth.password, (function(_this) {
          return function(err, body, headers) {
            if (err) {
              return _this.emit('error', err.toString());
            }
            _this.nano = new Nano({
              url: url,
              cookie: headers['set-cookie']
            });
            return _this.emit('ready', _this);
          };
        })(this));
      } else {
        process.nextTick((function(_this) {
          return function() {
            _this.nano = nano;
            return _this.emit('ready', _this);
          };
        })(this));
      }
    }

    Queue.prototype.createQueue = function() {
      this.nano.db.create(this.db, (function(_this) {
        return function(err, body) {
          var design, queue;
          if (err) {
            return _this.emit('error', (function() {
              switch (err.error) {
                case 'file_exists':
                  return "Database " + this.db + " already exists. Please delete it first";
                default:
                  return err.toString();
              }
            }).call(_this));
          }
          queue = _this.nano.use(_this.db);
          design = {
            language: "coffeescript",
            views: {
              count: {
                map: "(doc) -> emit null, if doc.pending then [1, 0] else [0, 1]",
                reduce: "(keys, values, rereduce) ->\n  values.reduce (prev, current) ->\n    left = prev[0] + current[0]\n    right = prev[1] + current[1]\n    [left, right]\n  , [0, 0]"
              },
              dequeued: {
                map: "(doc) -> emit doc.dequeued, doc.payload unless doc.pending"
              },
              fifo: {
                map: "(doc) -> emit doc.enqueued, doc.payload if doc.pending"
              }
            }
          };
          if (_this.username) {
            design.validate_doc_update = "(doc, old, userCtx) -> throw 'Not authorised' unless userCtx.name is '" + _this.username + "'";
          }
          return queue.insert(design, '_design/queue', function(err, body) {
            if (err) {
              return _this.emit('error', err.toString());
            }
            return _this.emit('created', _this);
          });
        };
      })(this));
      return this;
    };

    Queue.prototype.enqueue = function(payload) {
      var ee, queue;
      ee = new EventEmitter;
      queue = this.nano.use(this.db);
      queue.insert({
        pending: true,
        enqueued: new Date,
        payload: payload
      }, (function(_this) {
        return function(err) {
          if (err) {
            return ee.emit('error', err.toString());
          }
          return ee.emit('enqueued', payload);
        };
      })(this));
      return ee;
    };

    Queue.prototype.dequeue = function() {
      var queue;
      queue = this.nano.use(this.db);
      queue.view('queue', 'fifo', {
        limit: 1,
        include_docs: true
      }, (function(_this) {
        return function(err, body) {
          var doc;
          if (err) {
            return _this.emit('error', err.toString());
          }
          if (body.total_rows) {
            doc = body.rows[0].doc;
            doc.dequeued = new Date;
            doc.pending = false;
            return queue.insert(doc, function(err, result) {
              if (!err) {
                return _this.emit('dequeued', doc.payload);
              }
              if (err.error !== 'conflict') {
                return _this.emit('error', err.toString());
              }
              return setTimeout(function() {
                return _this.dequeue();
              }, Math.floor(Math.random() * 500));
            });
          } else {
            return _this.nano.db.changes(_this.db, function(err, result) {
              if (err) {
                return _this.emit('error', err.toString());
              }
              return _this.nano.db.changes(_this.db, {
                feed: 'longpoll',
                since: result.last_seq,
                heartbeat: true
              }, function(err, result) {
                if (err) {
                  return _this.emit('error', err.toString());
                }
                return setTimeout(function() {
                  return _this.dequeue();
                }, Math.floor(Math.random() * 500));
              });
            });
          }
        };
      })(this));
      return this;
    };

    Queue.prototype.count = function() {
      var queue;
      queue = this.nano.use(this.db);
      queue.view('queue', count, (function(_this) {
        return function(err, body) {
          var count;
          if (err) {
            return _this.emit('error', err.toString());
          }
          count = body.rows[0].value;
          return _this.emit('remaining', {
            total: value[0] + value[1],
            pending: value[0],
            processed: value[1]
          });
        };
      })(this));
      return this;
    };

    Queue.prototype.empty = function() {
      var queue;
      queue = this.nano.use(this.db);
      queue.list(function(err, body) {
        var i, jobs, len, ref, row;
        jobs = [];
        ref = body.rows;
        for (i = 0, len = ref.length; i < len; i++) {
          row = ref[i];
          if (!row.id.match(/^_design\./)) {
            so(function(row) {
              return jobs.push(function(callback) {
                return queue.destroy(row.id(row.value.rev, callback));
              });
            });
          }
        }
        return Async.parallelLimit(jobs, 100, function(err, results) {
          if (err) {
            throw err;
          }
          return this.nano.db.compact(this.db, 'queue', function(err, body) {
            if (err) {
              return emit('error', err);
            }
            return this.emit('empty', this);
          });
        });
      });
      return this;
    };

    return Queue;

  })(EventEmitter);

  module.exports = Queue;

}).call(this);
