// Generated by CoffeeScript 2.0.1
(function() {
  var Async, EventEmitter, Nano, Queue;

  Async = require('async');

  Nano = require('nano');

  EventEmitter = require('events');

  Queue = class Queue extends EventEmitter {
    constructor(db = 'couch-queue', url = 'http://127.0.0.1:5984', auth) {
      var nano;
      super();
      this.db = db;
      nano = new Nano(url);
      if (auth != null) {
        if (!(auth.username && auth.password)) {
          return process.nextTick(() => {
            return this.emit('error', "Both username and password needed to authenticate");
          });
        }
        this.username = auth.username;
        nano.auth(auth.username, auth.password, (err, body, headers) => {
          if (err) {
            return this.emit('error', err.toString());
          }
          this.nano = new Nano({
            url: url,
            cookie: headers['set-cookie']
          });
          return this.emit('ready', this);
        });
      } else {
        process.nextTick(() => {
          this.nano = nano;
          return this.emit('ready', this);
        });
      }
    }

    createQueue() {
      this.nano.db.create(this.db, (err, body) => {
        var design, queue;
        if (err) {
          return this.emit('error', (function() {
            switch (err.error) {
              case 'file_exists':
                return `Database ${this.db} already exists. Please delete it first`;
              default:
                return err.toString();
            }
          }).call(this));
        }
        queue = this.nano.use(this.db);
        design = {
          language: "coffeescript",
          views: {
            count: {
              map: "(doc) -> emit null, if doc.pending then [1, 0] else [0, 1]",
              reduce: "(keys, values, rereduce) ->\n  values.reduce (prev, current) ->\n    left = prev[0] + current[0]\n    right = prev[1] + current[1]\n    [left, right]\n  , [0, 0]"
            },
            dequeued: {
              map: "(doc) -> emit doc.dequeued, doc.payload unless doc.pending"
            },
            fifo: {
              map: "(doc) -> emit doc.enqueued, doc.payload if doc.pending"
            }
          }
        };
        if (this.username) {
          design.validate_doc_update = `(doc, old, userCtx) -> throw 'Not authorised' unless userCtx.name is '${this.username}'`;
        }
        return queue.insert(design, '_design/queue', (err, body) => {
          if (err) {
            return this.emit('error', err.toString());
          }
          return this.emit('created', this);
        });
      });
      return this;
    }

    enqueue(payload) {
      var ee, queue;
      ee = new EventEmitter;
      queue = this.nano.use(this.db);
      queue.insert({
        pending: true,
        enqueued: new Date,
        payload: payload
      }, (err) => {
        if (err) {
          return ee.emit('error', err.toString());
        }
        return ee.emit('enqueued', payload);
      });
      return ee;
    }

    dequeue() {
      var queue;
      queue = this.nano.use(this.db);
      queue.view('queue', 'fifo', {
        limit: 1,
        include_docs: true
      }, (err, body) => {
        var doc;
        if (err) {
          return this.emit('error', err.toString());
        }
        if (body.total_rows) {
          doc = body.rows[0].doc;
          doc.dequeued = new Date;
          doc.pending = false;
          return queue.insert(doc, (err, result) => {
            if (!err) {
              return this.emit('dequeued', doc.payload);
            }
            if (err.error !== 'conflict') {
              return this.emit('error', err.toString());
            }
            return setTimeout(() => {
              return this.dequeue();
            }, Math.floor(Math.random() * 500)); // Try again up to 500 ms later
          });
        } else {
          return this.nano.db.changes(this.db, (err, result) => {
            if (err) {
              return this.emit('error', err.toString());
            }
            return this.nano.db.changes(this.db, {
              feed: 'longpoll',
              since: result.last_seq,
              heartbeat: true
            }, (err, result) => {
              if (err) {
                return this.emit('error', err.toString());
              }
              return setTimeout(() => {
                return this.dequeue();
              }, Math.floor(Math.random() * 500)); // Try again up to 500 ms later
            });
          });
        }
      });
      return this;
    }

    count() {
      var queue;
      queue = this.nano.use(this.db);
      queue.view('queue', count, (err, body) => {
        var count;
        if (err) {
          return this.emit('error', err.toString());
        }
        count = body.rows[0].value;
        return this.emit('remaining', {
          total: value[0] + value[1],
          pending: value[0],
          processed: value[1]
        });
      });
      return this;
    }

    empty() {
      var queue;
      queue = this.nano.use(this.db);
      queue.list((err, body) => {
        var fn, i, jobs, len, row, rows;
        rows = (function() {
          var i, len, ref, results1;
          ref = body.rows;
          results1 = [];
          for (i = 0, len = ref.length; i < len; i++) {
            row = ref[i];
            if (!row.id.match(/^_design\//)) {
              results1.push(row);
            }
          }
          return results1;
        })();
        if (rows.length === 0) {
          return process.nextTick(() => {
            return this.emit('empty', this);
          });
        }
        jobs = [];
        fn = function(row) {
          return jobs.push(function(callback) {
            return queue.destroy(row.id, row.value.rev, callback);
          });
        };
        for (i = 0, len = rows.length; i < len; i++) {
          row = rows[i];
          fn(row);
        }
        return Async.parallelLimit(jobs, 100, (err, results) => {
          if (err) {
            return this.emit('error', err);
          }
          return this.nano.db.compact(this.db, 'queue', (err, body) => {
            if (err) {
              return this.emit('error', err);
            }
            return this.emit('empty', this);
          });
        });
      });
      return this;
    }

  };

  module.exports = Queue;

}).call(this);
