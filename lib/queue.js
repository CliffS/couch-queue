// Generated by CoffeeScript 1.10.0
(function() {
  var Nano, Queue,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Nano = require('nano');

  Queue = (function(superClass) {
    extend(Queue, superClass);

    function Queue(db, url, auth) {
      var nano;
      this.db = db != null ? db : 'couch-queue';
      if (url == null) {
        url = 'http://127.0.0.1:5984';
      }
      if (auth != null) {
        return process.nextTick(function() {
          if (!(auth.username && auth.password)) {
            return this.emit('error', "Both username and password needed to authenticate");
          }
        });
      }
      nano = new Nano(this.url);
      if (auth) {
        nano.auth(auth.username, auth.password, function(err, body, headers) {
          if (err) {
            return this.emit('error', err.toString());
          }
          this.nano = new Nano({
            url: url,
            cookie: headers['set-cookie']
          });
          return this.emit('ready', this);
        });
      } else {
        process.nextTick(function() {
          this.nano = nano;
          return this.emit('ready', this);
        });
      }
    }

    Queue.prototype.createQueue = function() {
      this.nano.db.create(this.db, (function(_this) {
        return function(err, body) {
          var queue;
          if (err) {
            return _this.emit('error', (function() {
              switch (err.error) {
                case 'file_exists':
                  return "Database " + this.db + " already exists. Please delete it first";
                default:
                  return err.toString();
              }
            }).call(_this));
          }
          queue = _this.nano.use(_this.db);
          return queue.insert({
            language: "coffeescript",
            views: {
              count: {
                map: "(doc) -> emit null, 1 if doc.pending",
                reduce: "(keys, values) -> sum values"
              },
              dequeued: {
                map: "(doc) -> emit doc.dequeued, doc.payload unless doc.pending"
              },
              fifo: {
                map: "(doc) -> emit doc.enqueued, doc.payload if doc.pending"
              }
            }
          }, '_design/queue', function(err, body) {
            if (err) {
              return _this.emit('error', err.toString());
            }
            return _this.emit('created', _this);
          });
        };
      })(this));
      return this;
    };

    Queue.prototype.enqueue = function(payload) {
      var queue;
      queue = this.nano.use(this.db);
      queue.insert({
        pending: true,
        enqueued: new Date,
        payload: payload
      }, (function(_this) {
        return function(err) {
          if (err) {
            return _this.emit('error', err.toString());
          }
          return _this.emit('enqueued', payload);
        };
      })(this));
      return this;
    };

    Queue.prototype.dequeue = function() {
      var queue;
      queue = this.nano.use(this.db);
      queue.view('queue', 'fifo', {
        limit: 1
      }, (function(_this) {
        return function(err, body) {
          var row;
          if (err) {
            return _this.emit('error', err.toString());
          }
          if (body.total_rows) {
            row = body.rows[0];
            return queue.get(row.id, function(err, doc) {
              if (err) {
                return _this.emit('error', err.toString());
              }
              doc.dequeued = new Date;
              doc.pending = false;
              queue.insert(doc, function(err, result) {});
              if (!err) {
                return _this.emit('dequeued', doc.payload);
              }
              if ((err != null ? err.error : void 0) !== 'conflict') {
                return _this.emit('error', err.toString());
              }
              return setTimeout(function() {
                return _this.dequeue();
              }, Math.floor(Math.random() * 500));
            });
          } else {
            return nano.db.changes(_this.db, function(err, result) {
              if (err) {
                return _this.emit('error', err.toString());
              }
              return nano.db.changes(_this.db, {
                feed: 'longpoll',
                since: result.last_seq,
                heartbeat: true
              }, function(err, result) {
                if (err) {
                  return _this.emit('error', err.toString());
                }
                return setTimeout(function() {
                  return _this.dequeue();
                }, Math.floor(Math.random() * 500));
              });
            });
          }
        };
      })(this));
      return this;
    };

    Queue.prototype.count = function() {
      var queue;
      queue = this.nano.use(this.db);
      queue.view('queue', count, (function(_this) {
        return function(err, body) {
          if (err) {
            return _this.emit('error', err.toString());
          }
          return _this.emit('remaining', body.rows[0].value);
        };
      })(this));
      return this;
    };

    return Queue;

  })(EventEmitter);

}).call(this);
